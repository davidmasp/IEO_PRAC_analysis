---
title: "Analysis of a TCGA RNA-seq data set on Prostate Adenocarcinoma "
author: "Joan Martí, David Mas, Adrià Auladell"
date: "29 de abril de 2016"
output: html_document
---

# Introduction

[Prostate cancer](https://en.wikipedia.org/wiki/Prostate_cancer)
is a disease of the prostate, a walnut-size gland in the male
reproductive system.  Nearly all prostate cancer is prostate adenocarcinoma.
 Prostate cancer is graded based on its Gleason score, which is how the cells
 look under a microscope and ranges from two to ten. A low Gleason score means
 that the cancer tissue is similar to normal cells and unlikely to spread. A
 high Gleason score means that the cancer cells are very different from normal
 cells and are likely to spread. For patients whose cancer has spread, their
 survival time is usually one to three years. It was estimated that for 2011,
 240,890 men would be diagnosed and 33,720 would die from prostate cancer.

The Cancer Genome Atlas already studied this dataset for a wide characterization of the prostate adenocarcinoma subtypes. TCGA established the following points:

* 74% of all tumors being assignable to one of seven molecular classes based on distinct oncogenic drivers: 
    - fusions involving (1) **ERG**, (2) **ETV1**, (3) **ETV4**, or (4) **FLI1** (46%, 8%, 4%, and 1%, respectively)
    - mutations in (5) **SPOP** or (6) **FOXA1**; or (7) **IDH1**. (11%, 3%, and 1%, respectively).
    
* 25% of the prostate cancers had a presumed actionable lesion in the PI3K or MAPK signaling pathways, and DNA repair genes were inactivated in 19%.

You can find the full article [here](http://dx.doi.org/10.1016/j.cell.2015.10.025).

## Data import
First, we install the packages using BiocInstaller:

```{r install, eval=FALSE}
source("http://www.bioconductor.org/biocLite.R")
library(BiocInstaller)
biocLite(c("edgeR","SummarizedExperiment","geneplotter","sva"))
install.packages(ggplot2)
```

After installing, we use them to import the [dataset](http://functionalgenomics.upf.edu/courses/IEO/projects/datasets/sePRAD.rds) (in RDS format):


```{r loading, message=FALSE}
library("SummarizedExperiment")
library("edgeR")
library("geneplotter")
library("ggplot2")
```

```{r load}
pracse <- readRDS("data/sePRAD.rds")
pracse

```

Then, we observe the distribution of the dataset.
```{r dim}
dim(colData(pracse))
```

Our dataset presents 554 different samples, presenting 549 clinical variables.
```{r data}
colData(pracse)[1:5, 1:5]
mcols(colData(pracse), use.names=TRUE)
```
By observing the clinical attributes of the samples, from the 549 present some of them have information collected and others present NA values. Our interest is present in the variables with some value present.There are variables related directly with prostate cancer, like the gleason score, the measurement of the development of the adenocarcinoma. 

By looking at the metadata, we observe the common structure followed in the datasets of the TCGA project. The first column is the clinical variable abreviated, the second a succint explanation of the variable and the last one the [CDEID](https://www.nlm.nih.gov/cde/glossary.html#cdedefinition ) code to obtain more information. 

```{r table types}
table(pracse$type)

```

The dataset presents 554 samples, with 52 obtained for healthy individuals and 502 from patients presenting a tumor. 

By looking at the row data, in this case genes of the sample, we observe the following:

```{r}
rowRanges(pracse)
```

For each gene we have present the chromosome, the range of position, the strand, his symbol (here in the dataset each gene is represented only by a number), the length of the transcript and the GC content. 


## Subsetting the Data

In order to reduce the sample size and to reduce the computational costs of the analysis we have decided to subset our data. We will use several approaches in order to do perform this action and later on we will apply one or other subset if we want to avoid the disadvantages of a defined strategy.

* Paired Subsetting. In the paired subsetting we try to get only the patients (based on the bcr barcode) that have a normal sample and a tumor one. This approach is suitable to distinguish exactly the gene expression changes that drive the tunmour. However, it also drives some disadvantages as we have been taugh in class.


```{r subset}
# Subset the paired samples
## we build a table from the bcr barcode occurences in our dataset
n_occur <- data.frame(table(colData(pracse)$bcr_patient_barcode))

## we filter out the na patients (having a na in the barcode)
## and the ones that occur only 1 time (they are unique)
pracse.filt.dupl <- pracse[,colData(pracse)$bcr_patient_barcode
                 %in% n_occur$Var1[n_occur$Freq > 1] & 
                 !is.na(colData(pracse)$bcr_patient_barcode)]

## See the results.
table(colData(pracse.filt.dupl)$type)
```
  As seen in the resulting numbers, we have filter out 454 patients that were not paired. We have same number of normal samples and tumor samples (50) because for each individual we have 2 samples, each one in a different group. 
  
* Non-Paired Subsetting - With this strategy we want to discard all the paired data in order to obtain only unique individuals. Our aim is to only get the normal samples of the replicated individuals. As the initial filter strategy get rid of most of the normal samples and kept the tumor ones we had to adapt it and generate a more complex filter as you can see below. 
  The replicated samples are 2 samples extracted from the same individual in 2 different conditions (tumor and normal). We want to distinguish general variation that is associated to one or the other subset and introducing 2 samples for the same individual could include batch effect in our samples. 

```{r nonpaired subset}
# Subset the non-paired 
pracse.filt.unique <- pracse[, colData(pracse)$bcr_patient_barcode 
                             %in% n_occur$Var1[n_occur$Freq == 1] & 
                                !is.na(colData(pracse)$bcr_patient_barcode) |
                                (colData(pracse)$bcr_patient_barcode %in% 
                                n_occur$Var1[n_occur$Freq > 1] & 
                                colData(pracse)$type == "normal" & 
                                !is.na(colData(pracse)$bcr_patient_barcode))]
table(colData(pracse.filt.unique)$type)

```
  In the resuting table we can see that all the normal samples remain meanwhile we have filter out 67 tumor samples that contained `NA`values in the bcr barcode field or that they were extracted from the same individuals that provided the normal samples. 

## Normalizing

Having understood completely our dataset, to perform efficiently quality assesment and normalization of the data, we have to convert our values to counts per million values (CPM). In order to do that, the package edgeR is used, creating a 'DGEList Object'. 
Digital Gene Expression data class (DGE) has benn implemented for storing read counts and associated information from digital gene expression or sequencing technologies. The user specifies the counts, the samples, and optional components include the genes and the groups.

```{r dge, warning= FALSE}
dge <- DGEList(counts = assays(pracse)$counts, genes = mcols(pracse), group = pracse$type)
head(dge$samples)
```

Finally, from each CPM value we calculate the $\log_2$ measure and we include it in our dataset in order to use it in the following comparisons/normalizations. 

```{r log2}
assays(pracse)$logCPM <- cpm(dge, log=TRUE, prior.count=3.5)
assays(pracse)$logCPM[1:5, 1:5]
```

#### Filtering by library size
Now we subset our dataset by library size, which is a measure of sequencing deepness or how robust are the RNA-seqs by samples.

```{r lib_size}
# library size, all samples
ord <- order(dge$samples$lib.size/1e6)
#plot(density(dge$samples$lib.size/1e6))
barplot((dge$sample$lib.size/1e06)[ord], las=1, ylab="Millions of reads",
        xlab="Samples", col=c("blue", "red")[(pracse$type[ord] == "tumor") + 1])
legend("topleft", c("tumor", "normal"), fill=c("red", "blue"), inset=0.01)

# filtering
dge.filtered <- dge[,(dge$samples$lib.size/1e6) > 50 ] # take 50e06 as an arbitrary threshold value
table(dge.filtered$samples$group)

ord <- order(dge.filtered$samples$lib.size/1e6)
#plot(density(dge.filtered$samples$lib.size/1e6))
barplot((dge.filtered$sample$lib.size/1e06)[ord], las=1, ylab="Millions of reads",
        xlab="Samples", col=c("blue", "red")[(dge.filtered$sample$group[ord] == "tumor") + 1])
legend("topleft", c("tumor", "normal"), fill=c("red", "blue"), inset=0.01)

```
We obtain the following dataset: normal 25 out of 52, tumor 112 out of 502.