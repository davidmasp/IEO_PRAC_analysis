---
title: "Analysis of a TCGA RNA-seq data set on Prostate Adenocarcinoma "
author: "Joan Martí, David Mas, Adrià Auladell"
date: "29 de abril de 2016"
output: html_document
---

# Introduction

[Prostate cancer](https://en.wikipedia.org/wiki/Prostate_cancer)
is a disease of the prostate, a walnut-size gland in the male
reproductive system.  Nearly all prostate cancer is prostate adenocarcinoma.
 Prostate cancer is graded based on its Gleason score, which is how the cells
 look under a microscope and ranges from two to ten. A low Gleason score means
 that the cancer tissue is similar to normal cells and unlikely to spread. A
 high Gleason score means that the cancer cells are very different from normal
 cells and are likely to spread. For patients whose cancer has spread, their
 survival time is usually one to three years. It was estimated that for 2011,
 240,890 men would be diagnosed and 33,720 would die from prostate cancer.

The Cancer Genome Atlas already studied this dataset for a wide characterization of the prostate adenocarcinoma subtypes. TCGA established the following points:

* 74% of all tumors being assignable to one of seven molecular classes based on distinct oncogenic drivers: 
    - fusions involving (1) **ERG**, (2) **ETV1**, (3) **ETV4**, or (4) **FLI1** (46%, 8%, 4%, and 1%, respectively)
    - mutations in (5) **SPOP** or (6) **FOXA1**; or (7) **IDH1**. (11%, 3%, and 1%, respectively).
    
* 25% of the prostate cancers had a presumed actionable lesion in the PI3K or MAPK signaling pathways, and DNA repair genes were inactivated in 19%.

You can find the full article [here](http://dx.doi.org/10.1016/j.cell.2015.10.025).

## Data import
First, we install the packages using BiocInstaller:

```{r install, eval=FALSE}
source("http://www.bioconductor.org/biocLite.R")
library(BiocInstaller)
biocLite(c("edgeR","SummarizedExperiment","geneplotter","sva"))
install.packages(ggplot2)
```

After installing, we use them to import the [dataset](http://functionalgenomics.upf.edu/courses/IEO/projects/datasets/sePRAD.rds) (in RDS format):


```{r loading, message=FALSE}
library("SummarizedExperiment")
library("edgeR")
library("geneplotter")
library("ggplot2")
```

```{r load}
prac.se <- readRDS("data/sePRAD.rds")
prac.se

```

Then, we observe the distribution of the dataset.
```{r dim}
dim(colData(prac.se))
```

Our dataset presents 554 different samples, presenting 549 clinical variables.
```{r data}
colData(prac.se)[1:5, 1:5]
mcols(colData(prac.se), use.names=TRUE)
```
By observing the clinical attributes of the samples, from the 549 present some of them have information collected and others present NA values. Our interest is present in the variables with some value present.There are variables related directly with prostate cancer, like the gleason score, the measurement of the development of the adenocarcinoma. 

By looking at the metadata, we observe the common structure followed in the datasets of the TCGA project. The first column is the clinical variable abreviated, the second a succint explanation of the variable and the last one the [CDEID](https://www.nlm.nih.gov/cde/glossary.html#cdedefinition ) code to obtain more information. 

```{r table types}
table(prac.se$type)

```

The dataset presents 554 samples, with 52 obtained for healthy individuals and 502 from patients presenting a tumor. 

By looking at the row data, in this case genes of the sample, we observe the following:

```{r}
rowRanges(prac.se)
```

For each gene we have present the chromosome, the range of position, the strand, his symbol (here in the dataset each gene is represented only by a number), the length of the transcript and the GC content. 


## Subsetting the Data

In order to reduce the sample size and to reduce the computational costs of the analysis we have decided to subset our data. We will use several approaches in order to do perform this action and later on we will apply one or other subset if we want to avoid the disadvantages of a defined strategy.

* Paired Subsetting. In the paired subsetting we try to get only the patients (based on the bcr barcode) that have a normal sample and a tumor one. This approach is suitable to distinguish exactly the gene expression changes that drive the tunmour. However, it also drives some disadvantages as we have been taugh in class.

    As seen in the resulting numbers, we have filter out 454 patients that were not paired. We have same number of normal samples and tumor samples (50) because for each individual we have 2 samples, each one in a different group. 

```{r subset}
# Subset the paired samples
## we build a table from the bcr barcode occurences in our dataset
n_occur <- data.frame(table(colData(prac.se)$bcr_patient_barcode))

## we filter out the na patients (having a na in the barcode)
## and the ones that occur only 1 time (they are unique)
prac.se.dupl <- prac.se[,colData(prac.se)$bcr_patient_barcode
                 %in% n_occur$Var1[n_occur$Freq > 1] & 
                 !is.na(colData(prac.se)$bcr_patient_barcode)]

## See the results.
table(colData(prac.se.dupl)$type)
```
 

  
* Non-Paired Subsetting - With this strategy we want to discard all the paired data in order to obtain only unique individuals. Our aim is to only get the normal samples of the replicated individuals. As the initial filter strategy get rid of most of the normal samples and kept the tumor ones we had to adapt it and generate a more complex filter as you can see below. 

    The replicated samples are 2 samples extracted from the same individual in 2 different conditions (tumor and normal). We want to distinguish general variation that is associated to one or the other subset and introducing 2 samples for the same individual could include batch effect in our samples. 

    In the resuting table we can see that all the normal samples remain meanwhile we have filter out 67 tumor samples that contained `NA`values in the bcr barcode field or that they were extracted from the same individuals that provided the normal samples. 
    
```{r nonpaired subset}
# Subset the non-paired 
prac.se.unique <- prac.se[, colData(prac.se)$bcr_patient_barcode 
                             %in% n_occur$Var1[n_occur$Freq == 1] & 
                                !is.na(colData(prac.se)$bcr_patient_barcode) |
                                (colData(prac.se)$bcr_patient_barcode %in% 
                                n_occur$Var1[n_occur$Freq > 1] & 
                                colData(prac.se)$type == "normal" & 
                                !is.na(colData(prac.se)$bcr_patient_barcode))]
table(colData(prac.se.unique)$type)

```
  


## Normalizing

Having understood completely our dataset, to perform efficiently quality assesment and normalization of the data, we have to convert our values to counts per million values (CPM). In order to do that, the package edgeR is used, creating a 'DGEList Object'. 
Digital Gene Expression data class (DGE) has benn implemented for storing read counts and associated information from digital gene expression or sequencing technologies. The user specifies the counts, the samples, and optional components include the genes and the groups.

```{r dge, warning= FALSE}
prac.dge <- DGEList(counts = assays(prac.se)$counts, genes = mcols(prac.se), group = prac.se$type)
head(prac.dge$samples)
```

Finally, from each CPM value we calculate the $\log_2$ measure and we include it in our dataset in order to use it in the following comparisons/normalizations. 

```{r log2}
assays(prac.se)$logCPM <- cpm(prac.dge, log=TRUE, prior.count=3.5)
assays(prac.se)$logCPM[1:5, 1:5]
```

#### Filtering by library size
Now we subset our dataset by library size, which is a measure of sequencing deepness or how robust are the RNA-seqs by samples. We renormalize the data with the new `SE`filtred element. 

```{r normalitzation of the filtred dataset, warning= FALSE}
prac.dge.unique <- DGEList(counts = assays(prac.se.unique)$counts, genes = mcols(prac.se.unique), group = prac.se.unique$type)
```

```{r library size all after filter unique, echo=FALSE, fig.align='center', fig.cap='Library Size per sample in the unique dataset'}

ord <- order(prac.dge.unique$samples$lib.size/1e6)
barplot((prac.dge.unique$sample$lib.size/1e06)[ord], las=1, ylab="Millions of reads",
        xlab="Samples", col=c("blue", "red")[(prac.se$type[ord] == "tumor") + 1])
legend("topleft", c("tumor", "normal"), fill=c("red", "blue"), inset=0.01)
```


In the plot, we cannot distinguish the different samples due the large number of samples. We will filter in a high treshold of sequencing depth to recude the number of samples erasing the ones with less sequencing quality. 


```{r lib.unique}
# library size, non-paired samples
prac.dge.unique.filtlib <- prac.dge.unique[,(prac.dge.unique$samples$lib.size/1e6) > 50 ] # 50e06 as threshold value
table(prac.dge.unique.filtlib$samples$group)
```

```{r figure library size, echo=FALSE, fig.align='center', fig.cap='Density distribution for the sample density using already filtred data by sequencing depth.'}
ord.unique <- order(prac.dge.unique.filtlib$samples$lib.size/1e6)
plot(density(prac.dge.unique.filtlib$samples$lib.size/1e6),main = "Density Plot of pruned samples by lib size")

```

```{r barplot libsize samples filtred 2, echo=FALSE, fig.align='center',fig.cap="Barplot of the final selected samples with its library size."}
barplot((prac.dge.unique.filtlib$sample$lib.size/1e06)[ord.unique], las=1, ylab="Millions of reads",
        xlab="Samples", col=c("blue", "red")[(prac.dge.unique.filtlib$sample$group[ord.unique] == "tumor") + 1])

legend("topleft", c("tumor", "normal"), fill=c("red", "blue"), inset=0.01)
```

After filtering, we obtain a dataset of 25 normal samples and 81 tumor. We introduce it again in the prac.se dataset to obtain the final filtered version.

```{r final dataset}

prac.se.sub <- prac.se.unique[,rownames(prac.dge.unique.filtlib$samples)]
```


## Diferential Gene Expression Analysis

Once we have our filtered dataset, we observe the density distribution of the tumor and normal samples separatedly. 

```{r Multydensity, fig.align='center', fig.cap='multidensity plot representing the clusters of the non expressed genes at the left and the expressed genes at the right.', echo=FALSE}
MDS_normal <- prac.dge.unique.filtlib[,prac.dge.unique.filtlib$samples$group == 'normal']
MDS_tumor <- prac.dge.unique.filtlib[,prac.dge.unique.filtlib$samples$group == 'tumor']

logCPM.MDS_normal <- cpm(MDS_normal, log = TRUE, prior.count = 3.25)
logCPM.MDS_tumor <- cpm(MDS_tumor, log = TRUE, prior.count = 3.25)

par(mfrow=c(1,2))
multidensity(as.list(as.data.frame(logCPM.MDS_normal)), xlab = "log2 CPM", legend = NULL, main = "Normal samples")
multidensity(as.list(as.data.frame(logCPM.MDS_tumor)), xlab = "log2 CPM", legend = NULL, main = "Tumor samples")

```
Seeing the graphs, we cannot establish differences between the tumoral/normal levels of expression.

Ending the sample study, we can observe the distribution of the log2CPM by gene. We will erase the genes presenting a logCPM below 1, since for values below 1 the CPM values are non significant. 

```{r avgexp gene, fig.align='center', fig.cap='Histogram presenting gene frequency expression for different logCPM values'}
assays(prac.se.sub)$logCPM <- cpm(prac.dge.unique.filtlib, log=TRUE, prior.count=0.5)

avgexp <- rowMeans(assays(prac.se.sub)$logCPM)

hist(avgexp, xlab="log2 CPM", main="", las=1)

abline(v=1, col="red", lwd=2)

```

As shown in the histogram, there are enough values below 1 to filter. In order to do that, we create a mask able to erase them from our dataset. 

```{r gene filt}
mask <- avgexp > 1
dim(prac.se.sub)

prac.se.sub <- prac.se.sub[mask, ]
dim(prac.se.sub)

dim(prac.dge.unique.filtlib )


prac.dge.unique.filtlib <- prac.dge.unique.filtlib[mask, ]
dim(prac.dge.unique.filtlib)

```

